import numpy as np
from skimage.metrics import structural_similarity as ssim

def build_full_polarity(spike_viz_info, timesteps_per_frame):
    
    split = spike_viz_info.split('_')
    split.remove('both')
    
    polarity = ['+', '-']
    timestep_inputs = []
    
    for i, p in enumerate(polarity):
        filepath = '_'.join(split[:-1] + [p, split[-1]]) + '.npy'
        timestep_inputs.append(np.load(filepath))
        
    timestep_inputs[1] *= -1
    timestep_full = timestep_inputs[0] + timestep_inputs[1]
    
    # Total spikes generated by timestep_full
    print(np.sum(np.sum(np.abs(timestep_full), axis=2)))
    
    # Denormalise 3D array, [-1, 1] => [0, 1]
    timestep_full = (timestep_full + timesteps_per_frame) / (2 * timesteps_per_frame)
    
    return timestep_full

timestep_naive_og = build_full_polarity('events_cheetah_downsampled_64_36_both_global', 1)
timestep_naive = build_full_polarity('events_cheetah_64_36_both_naive', 1)
timestep_v1 = build_full_polarity('events_cheetah_64_36_both_v1', 1)
timestep_v2 = build_full_polarity('events_cheetah_64_36_both_v2', 1)

def mse(imageA, imageB):
	# the 'Mean Squared Error' between the two images is the
	# sum of the squared difference between the two images;
	# NOTE: the two images must have the same dimension
	err = np.sum((imageA.astype("float") - imageB.astype("float")) ** 2)
	err /= float(imageA.shape[0] * imageA.shape[1])
	
	# return the MSE, the lower the error, the more "similar"
	# the two images are
	return err

def compare_images(imageA, imageB):
    
    m = mse(imageA, imageB)
    s, S = ssim(imageA, imageB, gaussian_weights=True, sigma=1.5, data_range=1.0, channel_axis=2, full=True)
    
    return m, s, S

# ssim score, [0, 1]
m_control, s_control, S_control = compare_images(timestep_naive_og, timestep_naive_og)
m_naive, s_naive, S_naive = compare_images(timestep_naive_og, timestep_naive)
m_v1, s_v1, S_v1 = compare_images(timestep_naive_og, timestep_v1)
m_v2, s_v2, S_v2 = compare_images(timestep_naive_og, timestep_v2)
print(s_naive)